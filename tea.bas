10 REM TEA ENCRYPTION/DECRYPTION FOR C64

20 POKE 55, 0 : POKE 56,202 : REM RESERVE MEMORY FOR ASM (ADJUST ACCORDINGLY)
21 REM EXAMPLE: 49152/256 = 192 (RESERVE $C000 AND ABOVE)
25 CLR

50 REM MEMORY ADDRESSES FOR BASIC TO ML DATA PASSING
51 A0 = 51200 : REM $C800 - MODE 0=ENCRYPT, 1=DECRYPT (1 BYTE)
52 A1 = 51201 : REM $C801 - CURRENT DATA BLOCK (8 BYTES)
53 A2 = 51209 : REM $C809 - KEY (16 BYTES)
60 A3 = 49152 : REM $C000 - SYS ADDRESS FOR ML ROUTINE

100 PRINT CHR$(147) : REM CLEAR SCREEN
101 PRINT "    TINY ENCRYPTION ALGORITHM (TEA)"
102 PRINT "    -------------------------------"
103 PRINT

200 PRINT "(E)NCRYPT OR (D)ECRYPT? "
201 REM INPUT MD$
202 MD$ = "D" : REM DBG
210 MD = -1
220 MD$ = LEFT$(MD$,1)
230 IF MD$ = "E" THEN MD = 0
240 IF MD$ = "D" THEN MD = 1
250 IF MD = -1 THEN PRINT "INVALID OPTION. (E OR D)" : GOTO 200
255 IF MD = 0 THEN GOTO 300 : REM GET STRING FOR ENCRYPT

260 PRINT "ENTER HEX STRING (MAX 128 CHARS):"
261 REM INPUT H$
262 H$ = "9C691C84625AF8B7"
265 IF LEN(H$) = 0 THEN PRINT "HEX CANNOT BE EMPTY" : GOTO 260
266 IF LEN(H$) > 128 THEN PRINT "HEX TOO LONG.": H$ = LEFT$(S$,128) : PRINT "TRUNCATED TO 128 CHARS."
267 IF INT(LEN(H$) / 2) <> LEN(H$) / 2 THEN PRINT "HEX LENGTH MUST BE EVEN." : GOTO 260
268 IF INT(LEN(H$) / 16) <> LEN(H$) / 16 THEN PRINT "HEX MUST BE MULTIPLE OF 16." : GOTO 260

270 REM CONVERT HEX STRING TO DECIMAL
275 S$ = ""
280 FOR I = 1 TO LEN(H$) STEP 2
281   C$ = MID$(H$, I, 1) : GOSUB 1100 : REM H1 = V
282   IF H1 = -1 THEN PRINT "INVALID HEX CHAR '"; C$; "' AT "; I : GOTO 260
283   C$ = MID$(H$, I+1, 1) : GOSUB 1100 : REM H2 = V
284   IF H2 = -1 THEN PRINT "INVALID HEX CHAR '"; C$; "' AT "; I+1 : GOTO 260
285   N = H1 * 16 + H2
286   S$ = S$ + CHR$(N)
287 NEXT I
288 PRINT "DBG: CONVERTED S$ LENGTH="; LEN(S$)
290 GOTO 330 : REM GET KEY

300 PRINT "ENTER STRING (MAX 64 CHARS):"
305 REM INPUT S$
306 S$ = "HELLO" : REM DBG
310 IF LEN(S$) = 0 THEN PRINT "STRING CANNOT BE EMPTY.": GOTO 300
320 IF LEN(S$) > 64 THEN PRINT "STRING TOO LONG.": S$ = LEFT$(S$,64) : PRINT "TRUNCATED TO 64 CHARS."

330 REM INPUT "ENTER 16 CHARACTER KEY:"; K$
331 K$ = "0123456789ABCDEF" : REM DBG
332 REM KEY NEEDS TO BE 128-BIT, SO 16 CHARS * 8 BITS = 128 BITS
340 IF LEN(K$) <> 16 THEN PRINT "KEY MUST BE EXACTLY 16 CHARACTERS." : GOTO 330

400 REM POKE DATA INTO MEMORY FOR USE IN ML ROUTINE
410 POKE A0, MD
420 FOR I = 0 TO 15
421   POKE A2 + I, ASC(MID$(K$, I+1, 1))
422 NEXT I

450 IF MD = 0 THEN PRINT "ENCRYPTING..."
451 IF MD = 1 THEN PRINT "DECRYPTING..."
460 R$ = ""
470 FOR BI = 1 TO LEN(S$) STEP 8
480   B$ = MID$(S$, BI, 8)
490   REM PAD LAST BLOCK IF LESS THAN 8 BYTES
500   IF LEN(B$) = 8 THEN GOTO 520 : REM SKIP PADDING
510   B$ = B$ + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0)
511   B$ = B$ + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0)
512   B$ = LEFT$(B$, 8)
520   REM PRINT "DBG: BLOCK="; CHR$(34); B$; CHR$(34)

530   REM POKE 8-BYTE BLOCK INTO ML AREA
540   FOR I = 0 TO 7
541     POKE A1 + I, ASC(MID$(B$, I+1, 1))
545   NEXT I

550   REM PRINT "DBG: CALLING ML AT SYS "; A3
555   SYS A3

560   REM PEEK PROCESSED BLOCK
570   PB$ = ""
580   FOR I = 0 TO 7
585     PB$ = PB$ + CHR$(PEEK(A1 + I))
590   NEXT I
600   REM PRINT "DBG: PROC BLOCK="; CHR$(34); PB$; CHR$(34)

610   R$ = R$ + PB$
620 NEXT BI

700 PRINT
701 IF MD = 0 THEN PRINT "ENCRYPTED HEX:"
702 IF MD = 1 THEN PRINT "DECRYPTED HEX:"
706 REM TODO: WRAP HEX DISPLAY EVERY 8 BYTES OR WHATEVER
710 FOR I = 1 TO LEN(R$)
711   N = ASC(MID$(R$, I, 1))
712   GOSUB 1000 : REM H$ = N IN HEX
713   PRINT H$;" ";
714 NEXT I
720 PRINT

850 PRINT
860 INPUT "RESTART? (Y/N)"; MD$
870 IF LEFT$(MD$,1) = "Y" THEN GOTO 100
880 PRINT "DONE"

900 END

1000 REM ----- SUBROUTINE: DECIMAL TO HEX STRING -----
1010 REM INPUT:  N (0-255)
1020 REM OUTPUT: H$ (2 CHAR HEX STRING)
1030 HD$="0123456789ABCDEF"
1040 H1 = INT(N / 16)
1050 H2 = N - (H1 * 16)
1060 D1$ = MID$(HD$, H1 + 1, 1)
1070 D2$ = MID$(HD$, H2 + 1, 1)
1080 H$ = D1$ + D2$
1090 RETURN

1100 REM ----- SUBROUTINE: HEX CHAR TO DECIMAL -----
1101 REM INPUT:  C$ (ONE HEX CHAR)
1102 REM OUTPUT: V (0-15), OR -1 IF INVALID
1110 V = ASC(C$)
1120 IF V >= 48 AND V <= 57 THEN V = V - 48 : RETURN : REM 0-9
1130 IF V >= 65 AND V <= 70 THEN V = V - 55 : RETURN : REM A-F (UPPER)
1140 IF V >= 97 AND V <= 102 THEN V = V - 87 : RETURN : REM A-F (LOWER)
1150 V = -1 : REM INVALID
1160 RETURN

1200 REM ----- SUBROUTINE: DEBUG BREAK -----
1201 REM INPUT: LN - LINE NUMBER
1210 PRINT "BREAK AT "; LN
1211 PRINT "PRESS ENTER TO CONTINUE"
1212 INPUT X$
1213 RETURN
